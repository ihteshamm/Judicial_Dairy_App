import _pt from "prop-types";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React, { useEffect, useState } from 'react';
import styles from './App.module.scss';
import icon from './assets/icon.svg';
import send from './assets/send.svg';
import description from './assets/description.svg';
import TextareaAutosize from 'react-textarea-autosize';
import MessageView from './Message';
import Options from './Options';
import moment from 'dayjs';

const ChatBot = props => {
  const {
    className,
    questions,
    lastMessage,
    onAnswer,
    initialMessages = []
  } = props;
  const [idleTime, setIdleTime] = useState(0);
  const [keyValue, setKeyValue] = useState({});
  const [currentQuestion, setCurrentQuestion] = useState();

  const updateQuestionsWithAnswers = answer => {
    const val = currentQuestion && _objectSpread(_objectSpread({}, keyValue), {}, {
      [currentQuestion.identifier]: answer
    });

    if (val) {
      setKeyValue(val);
    }

    const value = questions.map(each => each.identifier === currentQuestion?.identifier ? _objectSpread(_objectSpread({}, each), {}, {
      answered: true,
      answer
    }) : each);
    onAnswer(value, val);
  };

  const [open, setOpen] = useState(true);
  const [value, setValue] = useState('');
  const [chatList, setChatList] = useState(initialMessages);
  const [typing, setTyping] = useState(false);

  const onChange = e => {
    e.persist();
    setValue(e.target.value);
  };

  const [selected, setSelected] = useState([]);

  const onSelect = select => {
    const index = selected.findIndex(val => val === select);

    if (index !== -1) {
      return setSelected(val => val.filter((e, i) => i !== index));
    }

    setSelected(val => [...val, select]);
  };

  const onSend = () => {
    setIdleTime(0);

    if (value) {
      const time = moment().format();
      setChatList(val => [...val, {
        message: value,
        sender: 'user',
        time
      }]);
      const answer = currentQuestion?.answerType === 'csv' ? value.split(',') : value;

      if (currentQuestion?.validator) {
        const validatorCallBack = currentQuestion?.validator?.validatorCallback;

        if (validatorCallBack && !validatorCallBack(answer)) {
          setTyping(true);
          setTimeout(() => {
            setChatList(val => [...val, {
              message: currentQuestion?.validator?.message(value) || '',
              sender: 'bot',
              time
            }]);
            setTyping(false);
          }, 1000);
          return;
        }
      }

      updateQuestionsWithAnswers(answer);
      setValue('');
      return;
    }
  };

  const onFinish = () => {
    setIdleTime(0);
    const time = moment().format();
    const message = !selected.length ? `My ${currentQuestion?.identifier} not listed` : ` - ${selected.join(`\n - `)}`;
    setChatList(val => [...val, {
      message,
      sender: 'user',
      time
    }]);

    if (currentQuestion?.validator) {
      const validatorCallBack = currentQuestion?.validator?.validatorCallback;

      if (validatorCallBack && !validatorCallBack(selected)) {
        return setChatList(val => [...val, {
          message: currentQuestion?.validator?.message(selected) || '',
          sender: 'bot',
          time
        }]);
      }
    }

    setCurrentQuestion(undefined);
    updateQuestionsWithAnswers(selected);
    setSelected([]);
  };

  const onEnter = e => {
    if (e.charCode === 13 && value && !e.shiftKey) {
      onSend();
    }
  };

  useEffect(() => {
    setTyping(true);
    setTimeout(() => {
      const time = moment().format();
      const sender = 'bot';
      const unansweredQuestion = questions.find(question => !question.answered);
      setCurrentQuestion(unansweredQuestion);

      if (unansweredQuestion) {
        const message = unansweredQuestion.question(keyValue);
        setChatList(val => [...val, {
          message,
          sender,
          time
        }]);
      } else {
        const message = lastMessage(keyValue);
        setChatList(val => [...val, {
          message,
          sender,
          time
        }]);
      }

      setTyping(false);
    }, 1000); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [questions]);
  useEffect(() => {
    const list = document.getElementById('chat-list-body');

    if (list) {
      list.scrollTop = list.scrollHeight;
    }
  }, [chatList.length]);
  useEffect(() => {
    if (open) {
      const interval = setInterval(() => {
        setIdleTime(val => val + 1);
      }, 1000);
      return () => {
        clearInterval(interval);
        setIdleTime(0);
      };
    }
  }, [open]);
  useEffect(() => {
    if (idleTime >= 300) {
      setOpen(false);
    }
  }, [idleTime, currentQuestion]);
  const [, setRef] = useState(null);
  const [file, setFile] = useState({
    src: ''
  });

  const onSelectFile = () => {
    const time = moment().format();
    setChatList(val => [...val, {
      message: value,
      fileSrc: file.src,
      sender: 'user',
      time,
      file: file.file
    }]);
    updateQuestionsWithAnswers(file);
    setFile(val => _objectSpread(_objectSpread({}, val), {}, {
      src: ''
    }));
  };

  const onChangeFile = e => {
    const file = e.target.files && e.target.files[0];
    const reader = new FileReader();
    reader.readAsDataURL(file);

    reader.onloadend = () => {
      setFile({
        file,
        src: reader.result
      });
    };
  };

  return /*#__PURE__*/React.createElement("span", {
    className: [styles.chatBot, className].join(' ')
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      height: open ? 600 : 0,
      width: open ? 320 : 0,
      transition: `height ${open ? 800 : 0}ms ease-out`
    },
    className: styles.chatBody
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.header
  }, /*#__PURE__*/React.createElement("div", {
    className: styles.botLogo
  }, "BOT"), /*#__PURE__*/React.createElement("div", {
    className: styles.display
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontWeight: 'bold'
    }
  }, "Chat Assistant"), /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 4
    }
  }, typing ? 'typing...' : 'online')), /*#__PURE__*/React.createElement("button", {
    onClick: () => setOpen(false),
    "aria-label": "close",
    className: styles.close
  }, "\xD7")), /*#__PURE__*/React.createElement("div", {
    id: "chat-list-body",
    className: styles.body
  }, chatList.map((message, index) => /*#__PURE__*/React.createElement(MessageView, _extends({
    key: index
  }, message))), currentQuestion?.options && /*#__PURE__*/React.createElement(Options, {
    onFinish: onFinish,
    options: currentQuestion.options,
    onSelect: onSelect,
    selected: selected
  })), idleTime > 240 && /*#__PURE__*/React.createElement("div", {
    onClick: () => setIdleTime(0),
    className: styles.keepAlive,
    role: "button",
    "aria-label": "keep open"
  }, `Chat assistant will close in ${300 - idleTime} seconds. Click here to keep alive`), file.src && /*#__PURE__*/React.createElement("div", {
    className: styles.preview
  }, ['image/png', 'image/jpg'].includes(file.file.type) && /*#__PURE__*/React.createElement("img", {
    alt: "",
    src: file.src
  }), ['video/mp4'].includes(file.file.type) && /*#__PURE__*/React.createElement("video", {
    src: file.src
  }), !['video/mp4', 'image/png', 'image/jpg'].includes(file?.file?.type || '') && /*#__PURE__*/React.createElement("div", {
    className: styles.attachment
  }, /*#__PURE__*/React.createElement("img", {
    alt: "",
    src: description
  }), /*#__PURE__*/React.createElement("div", {
    className: styles.fileName
  }, file?.file?.name))), currentQuestion && /*#__PURE__*/React.createElement("div", {
    className: styles.footer
  }, ['input', 'csv', 'number'].includes(currentQuestion.answerType) && /*#__PURE__*/React.createElement("input", {
    placeholder: "Jot something down",
    onKeyPress: onEnter,
    onChange: onChange,
    value: value,
    type: currentQuestion.answerType === 'number' ? 'number' : 'text',
    className: styles.input
  }), ['paragraph'].includes(currentQuestion.answerType) && /*#__PURE__*/React.createElement(TextareaAutosize, {
    onKeyPress: onEnter,
    placeholder: "Jot something down",
    onChange: onChange,
    value: value,
    maxRows: 6,
    className: styles.input
  }), currentQuestion.answerType === 'file' && /*#__PURE__*/React.createElement("div", {
    className: styles.uploader,
    role: "button",
    onClick: () => {
      const element = document.getElementById('file-id');
      element && element.click();
    },
    style: {
      flex: 1
    },
    id: "file-upload-id"
  }, "Upload a file", /*#__PURE__*/React.createElement("input", {
    accept: '.pdf,.doc,.png,.jpg,.docx,.mp4,.mov',
    ref: setRef,
    onChange: onChangeFile,
    style: {
      display: 'none'
    },
    id: "file-id",
    type: "file"
  })), currentQuestion.answerType !== 'select' && /*#__PURE__*/React.createElement("img", {
    role: "button",
    onClick: currentQuestion.answerType === 'file' ? onSelectFile : onSend,
    className: styles.icon,
    alt: "",
    src: send
  }))), !open && /*#__PURE__*/React.createElement("div", {
    tabIndex: 0,
    "data-testid": "open",
    role: "button",
    onClick: () => setOpen(true),
    "aria-label": "send message",
    className: styles.button
  }, /*#__PURE__*/React.createElement("img", {
    alt: "",
    src: icon
  })));
};

ChatBot.propTypes = {
  className: _pt.string,
  lastMessage: _pt.func.isRequired,
  questions: _pt.arrayOf(_pt.shape({
    question: _pt.func.isRequired,
    answerType: _pt.any,
    identifier: _pt.string.isRequired,
    answer: _pt.any,
    answered: _pt.bool,
    options: _pt.arrayOf(_pt.string),
    fileSrc: _pt.string,
    validator: _pt.shape({
      message: _pt.func.isRequired,
      validatorCallback: _pt.func.isRequired
    })
  })).isRequired,
  onAnswer: _pt.func.isRequired,
  initialMessages: _pt.array
};
export default ChatBot;
//# sourceMappingURL=ChatBot.js.map